\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[margin=1.5in,left=1cm,right=1cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{graphicx}
\usepackage{color}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{fancyhdr}



\title{Title}
\author{Амеличев Константин, ПМИ 191.}
\date{Date}

\newcommand{\problem}[2]{

\section {Задача #1}
\textbf {Постановка задачи.} {#2}

\textbf {Решение.}
}

\newcommand{\limit}[2]{\displaystyle \lim_{#1 \to #2}}

\newcommand{\rangesum}[2]{\displaystyle \sum_{#1}^{#2}}

\newcommand{\mintedparams}{
% frame=lines
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray    
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Амеличев Константин, ПМИ 191, @kik0s, \href{http://github.com/kik0s}{\textcolor{blue}{github}}, \href{http://codeforces.com/profile/kikos}{\textcolor{blue}{codeforces}}, \href{http://vk.com/i_tried_to_name_myself_kikos}{\textcolor{blue}{vk}}}
\fancyhead[RE,LO]{Лекция АиСД 26.11}

\begin{document}

\textit{Какое-то сегодняшнее дополнение про бинарную кучу есть в прошлом конспекте}
\paragraph{K-чная куча}

Куча на полном K-чном дереве. Эту кучу можно так же хранить в массиве, с 0-индексацией.
\begin{itemize}
    \item $sift\_up$ такой же, $O(\log_k n)$
    \item $sift\_down$ ищет минимум среди $k$ элементов на каждом шаге, поэтому работает за $O(k \cdot \log_k n)$.
\end{itemize}

\begin{tabular}{c|c|c}
 & $2-heap$ & $k-heap$ \\
 \hline
 $insert$ & $O(\log n)$ & $O(k \log_k n)$ \\
 \hline
 $extract\_min$ & $O(\log n)$ & $O(k \log_k n)$ \\
 \hline
 $decrease key$ & $O(\log n)$ & $O(\log_k n)$ \\
 \hline
 $increase key$ & $O(\log n)$ & $O(k \log_k n)$ \\
 \hline
\end{tabular}

\paragraph{Дейкстра на $K$-ной куче}

Алгоритм Дейкстры достает минимум $n$ раз, и улучшает ключ $m$ раз

$$ a \cdot \log_k n = b \cdot k \cdot \log_k n, a = m, b = n$$

Отсюда $k = \frac{a}{b} = \frac{m}{n}$ в случае Дейкстры. Еще отметим, что $k \ge 2$.

В случае когда $a = b^q,\ q > 1$, то $k$-куча структура работает за $O(1)$ (вроде бы этот факт мы докажем в домашке), причем с хорошей константой, поэтому применимо на практике (привет, фибоначчиева куча!).

\paragraph{Амортизационный анализ}

Идея в том, что мы хотим оценить суммарное число операций, а не на каждом шаге работы. То есть вполне может быть итерация алгоритма за $O(n)$, но нам важно, что суммарное число $O(n \log n)$

Так что есть $t_{real} = t,\ t_{amortized} = \tilde t$.

\paragraph{Метод кредитов}

Элементам структуры сопоставляем сколько-то монет. Этими монетами элемент <<расплачивается>> за операции. Также мы накидываем сколько-то монет на операцию. Запрещаем отрицательное число монет. Начинаем с нулем везде.

Обозначим состояния структуры за $S_0, S_1, \dots, S_n$. Каждый переход стоил $t_i$, $t_i \ge |operations|$, Где $t_i$ --- это сколько мы потратили. Также на $i$-м шаге мы вбрасываем в систему $\tilde t_i$ монет. Тогда $$\sum t_i \le \sum \tilde t_i \le A \rightarrow O(A)$$

\paragraph{Стек с минимумом}

\begin{itemize}
    \item $min\_stack$
    \item push
    \item pop
    \item $get\_min$
\end{itemize}

$m_i = \min (m_{i-1}, a_i)$ --- поддерживаем минимумы. Операции тривиальны

\paragraph{Очередь с минимумом на двух стеках}

Храним два стека с минимумом, один из которых мысленно наращиваем в одну сторону, а другой в другую, при этом очередь выглядит как бы как склеенные стеки. То есть мы добавляем элемент в первый стек, а извлекать хотим из второго.

$$X \rightarrow a_n, a_{n - 1}, \dots, a_1,\ |\ , b_1, b_2, \dots, b_n \rightarrow Y$$

Тогда единственная сложная операция --- если мы хотим извлечь минимум, а второй стек пустой. Тогда мы все элементы из первого перекинем во второй по очереди с помощью <<извлеки-добавь>>

Почему это работает за $O(1)$ на операцию амортизированно? Представим каждому элементу при рождении 2 монеты, одну из которых мы потратим на добавление в первый стек, а вторую на удаление через второй.

\paragraph{set для бедных}

Хотим не делать $erase$, только $insert$, $find$, $get\_min$. Храним $\log n$ массивов, $|a_i| = 2^i$, каждый из которых по инварианту будет отсортирован. Тогда $get\_min$ рабтает за $O(\log n)$ --- просто берем минимум по всем массивам. Аналогично $find$ делается бинпоисками за $O(\log^2 n)$ 

А как добавлять за $\tilde O(\log n)$? Каждый элемент при добавлении в структуру получает $\log n$ монет. Когда мы добавляем элемент, мы создаем новый массив ранга 0. Если было два массива  ранга 0, сольем их в новый массив ранга 1 за суммарный размер (и заберем монетку у всех элементов во время слияния), и так далее, пока не создадим уникальный массив для текущего ранга.

\paragraph{Метод потенциалов}

$\Phi(S_i)$ --- потенциал, который зависит только от состояния структуры (\textbf{не от} последовательности действий, которая к такому состоянию привела).

Опять вводим $t_i$, $\sum t_i = O(f(n))$. Определим амортизированное время работы:

$$\tilde t_i = t_i + (\Phi(S_{i+1}) - \Phi(S_i))$$

$$t_i = \tilde t_i + \Phi(S_i) - \Phi(S_{i+1})$$

Пусть мы показали $\tilde t_i \le f(n)$. Тогда

$$\sum t_i \le n \cdot f(n) + \Phi(0) - \Phi(n)$$

Нормальный потенциал --- такой, что из неравенства выше все еще можно показать О-оценку на $\sum t_i = O(n \cdot f(n))$.

\paragraph{deque для богатых}

Хотим deque с поддержкой минимума.

Храним два стека как для обычной очереди. Все операции хорошо работают как на очереди, кроме перестройки структуры. В случае с очередью надо было переливать стеки только в одну сторону, а теперь иногда нужно туда-сюда.

Теперь мы будем перекидывать только половину элементов. Тогда нам понадобитсяя 3 стека, один из которых будет вспомогательным для перестройки (там иначе стеки развернуты).

$\Phi(S_i) = |Size_1 - Size_2|$



\end{document}
