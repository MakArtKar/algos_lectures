\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[margin=1.5in,left=1cm,right=1cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{graphicx}
\usepackage{color}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{fancyhdr}



\title{Title}
\author{Амеличев Константин, ПМИ 191.}
\date{Date}

\newcommand{\problem}[2]{

\section*{Задача #1}
\textbf {Постановка задачи.} {#2}

\textbf {Решение.}
}

\newcommand{\limit}[2]{\displaystyle \lim_{#1 \to #2}}

\newcommand{\rangesum}[2]{\displaystyle \sum_{#1}^{#2}}

\newcommand{\rangeint}[2]{\displaystyle \int_{#1}^{#2}}


\newcommand{\mintedparams}{
% frame=lines
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray    
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Амеличев Константин, ПМИ 191, @kik0s, \href{http://github.com/kik0s}{\textcolor{blue}{github}}, \href{http://codeforces.com/profile/kikos}{\textcolor{blue}{codeforces}}, \href{http://vk.com/i_tried_to_name_myself_kikos}{\textcolor{blue}{vk}}}
\fancyhead[RE,LO]{Лекция АиСД 07.04}

\begin{document}

\paragraph{Потоки.} Пусть нам дан некий ориентированный граф. У каждого ребра есть некоторая пропускная способность $c_{v, u}$ (можем полагать, что если ребра нет, то она равна нулю). Две вершины $s,\ t$ обозначены как сток и исток.

Далее мы выделяем какое-то множество путей $P = \{p_1(s, t), p_2(s, t), \ldots\}$. Каждому пути сопоставляем число $f_i \ge 0$. Требуется, чтобы для каждого ребра $e$ сумма $f_i$ по всем вхождениям ребра в пути не превосходила $c_e$. При таких условиях мы максимизируем $\sum f_i$.
\paragraph{Классический вид задачи.} Обозначим потоком функцию от пары вершин $f:\ V \times V \rightarrow \mathbb{R}$, на которую накладываются следующие требования:

\begin{enumerate}
    \item $f(v, u) \le c(v, u)$
    \item $f(v, u) = -f(u, v)$
    \item $\forall v \in V \setminus \{s, t\}: \displaystyle \sum_{u} f(v, u) = 0$
\end{enumerate}

Мы хотим максимизировать $|f| = \sum_{u} f(s, u) = \sum_{u} f(u, t)$.

Можно заметить, что можно определить сумму потоков $f_1 + f_2$, если выполняется пункт 1. Остальные свойства сохранятся.

Перевод из первой постановки задачи во вторую делается просто: вдоль каждого пути по прямым ребрам добавляем $+f_p$, а вдоль обратных ребер прибавляем $-f_p$. Тогда все три свойства выполнятся, и все хорошо. 

Определим $e_v = \displaystyle \sum_{u} f(v, u)$. Если мы выделим какое-то множество вершин, то поток, проходящий через множество равен сумме $e_v$. Можно заметить, что такое число это что-то из $\{0, |f|, -|f|\}$.

Ребро называется насыщенным если $f(v, u) = c(v, u)$. Остаточной пропускной способностью ребра $c*(v, u)$ назовем $(c - f)(v, u)$. Остаточной сетью назовем граф на множестве ребер, для которых $c*(v, u) \neq 0$.
\paragraph{Разрез.} Это такое разбиение вершин на множества $A$ и $\overline A$. Разрезы бывают ориентированные и неориентированные. В потоках мы почти всегда говорим про $s/t$-разрез --- $s \in A$, $t \notin A$, стоимость разреза определяем как $\displaystyle \sum_{v \in A} \sum_{u \notin A} c(v, u)$.

Разрез называется насыщенным, если все его ребра насыщенные.
\paragraph{Декомпозиция потока.} Поток можно представить в виде суммы $l \le m$ элементарных потоков (то есть путей и циклов). Доказательство конструктивное: пока общий поток ненулевой, из $s$ есть ребро, где $f > 0$. Проходя по нему, дальше тоже будет ребро с положительным потоком, итд. Получим путь $s \rightarrow t$, где можно уменьшить все $f$ на минимальное из потоков по ребрам. Если встретили цикл, то уменьшаем цикл, и продолжаем. Поскольку каждый раз добавлялось одно ребро с $f = 0$, то всего мы выделим не более $m$ элементарных потоков. В какой-то момент путей $s \rightarrow t$ не останется. Тогда в сети остались только циклы. Их можно выделить как элементарные потоки. Если нас интересует сведение второй постановки задачи к первой, то на циклы можно просто забить.

Размер декомпозиции можно оценить как $O(nm)$ --- $O(m)$ итераций, и $O(n)$ вершин в элементарном потоке. Найти за это время декомпозицию тоже можно. Для этого надо хранить указатель на текущее интересное исходящее ребро для каждой вершины. Тогда наш указатель либо двигается вправо (суммарно $O(m)$), либо мы находим какой-то новый элементарный поток. То есть, каждый шаг декомпозиции работает за $O(n)$ переходов по ребру, и все сдвиги указателя суммарно работают за $O(m)$ по всем шагам декомпозиции, получаем сложность $O(nm)$.



\end{document}
