\documentclass{article}

\usepackage[top=0.6in, bottom=0.75in, left=0.625in, right=0.625in]{geometry}
\usepackage{amsmath,amsthm,amssymb,hyperref}
\usepackage[utf8x]{inputenc}
\usepackage[russianb]{babel}
\usepackage{hyperref}
% \usepackage{minted}
\usepackage{color}
\usepackage{fancyhdr}
\usepackage[normalem]{ulem}


\newcommand{\R}{\mathbb{R}}  
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\tu}[1]{\underline{#1}}
\newcommand{\tb}[1]{\textbf{#1}}
\newcommand{\ti}[1]{\textit{#1}}
\newcommand{\aliq}{\mathrel{\raisebox{-0.5ex}{\vdots}}}
\newcommand{\mylim}[2]{\lim_{#1 \to #2}}
\newcommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\brackets}[1]{\left({#1}\right)}
\newcommand{\sqbrackets}[1]{\left[{#1}\right]}
\newcommand{\integral}{{\displaystyle \int}}

\newenvironment{theorem}[2][Theorem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{lemma}[2][Lemma]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{claim}[2][Claim]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{proposition}[2][Proposition]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
\newenvironment{corollary}[2][Corollary]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}

\newenvironment{solution}{\begin{proof}[Solution]}{\end{proof}}

\makeatletter
\newenvironment{sqcases}{%
  \matrix@check\sqcases\env@sqcases
}{%
  \endarray\right.%
}
\def\env@sqcases{%
  \let\@ifnextchar\new@ifnextchar
  \left\lbrack
  \def\arraystretch{1.2}%
  \array{@{}l@{\quad}l@{}}%
}
\makeatother

\ifx\pdfoutput\undefined
\usepackage{graphicx}
\else
\usepackage[pdftex]{graphicx}
\fi

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Макоян Артем, ПМИ 191-1, @MakArtKar, \href{http://github.com/MakArtKar}{\textcolor{blue}{github}}, \href{http://codeforces.com/profile/MakArtKar}{\textcolor{blue}{codeforces}}, \href{http://vk.com/makartkar}{\textcolor{blue}{vk}}}
\fancyhead[RE,LO]{Лекция по алгоритмам 20}

\begin{document}

На прошлой лекции мы показали, что паросочетание максимально $\Leftrightarrow$ для него не существует дополняющей цепи. \\

\verb'Поиск максимального паросочетания' \\
Ориентируем ребра парсоча справа-налево, а остальные - слева-направо. Тогда каждой удлиняющей цепи соответствует путь из левой свободной вершины в правую свободную. Путь можно искать за линейное время, получаем ассимптотику поиска паросочетания за $O(nm)$ (поиск пути можно делать не больше $n$ раз, так как в парсоче не больше $n$ ребер).

\verb'Алгоритм Куна' \\
Пробежимся по вершинам левой доли и попробуем найти удлиняющую цепь из текущей вершины. \\
\ti{Проблема}: Если из какой-то вершины мы не смогли найти удлиняющую цепь, то потом можем найти. \\
\begin{enumerate}
	\item Пусть $r(A) = \text{ max matching } (A, R), \text{ где } A \subset L$. $A_{i + 1} = A_i \cup \{v_i\}, A_0 = \{v_0\}$. Докажем, что если $r(A_{i-1})$ найден алгоритмом Куна корректно, то и $r(A_i)$ будет найден корректно. \\
	Понятно, что $r(A_{i-1}) \le r(A_i) \le r(A_{i-1}) + 1$.
	\begin{enumerate}
	\item Если $r(A_{i-1}) = r(A_i)$, то $r(A_i)$ посчитается правильно \\
	\item Если $r(A_{i-1}) + 1 = r(A_i)$. Пусть $M_i$ для $r(A_i)$ и $M_{i-1}$ - парсоч для $A_{i-1}$. Тогда рассмотрим симметрическую разность $M_i$ и $M_{i-1}$. Наш получившийся граф разбился на пути и циклы, так как $\abs{M_i} > \abs{M_{i-1}}$, то есть удлиняющая цепь для $M_{i-1}$. Если ее конец не в $v_i$, то можем увеличить $M_{i-1}$ - противоречие, значит есть удлиняющая цепь из $v_i$, а значит алгоритм Куна найдет ее и получит, что $r(A_i) = r(A_{i-1}) + 1$.
	\end{enumerate}
	\item Если какая-то вершина стала покрыта в течение алгоритма куна, то она и останется покрытой. \\
\end{enumerate}
Отсюда получем, что Кун находит лексикографически минимальный парсоч, то есть слева выбранные вершины будут лексикографически минимальными. \\

Теперь решим задачу: слева на вершинах есть неотрицательные веса, тогда хотим найти парсоч максимального веса (то есть максимизировать суммарный вес взятых вершин). \\
Переупорядочим вершины по весу, то есть туперь $w_1 \ge \ldots \ge w_n \ge 0$. Теперь запустим Куна на левой доли. Тогда получим оптимальный парсоч. Пусть $p_1 < \ldots < p_k$ - индексы $1$ в этом числе, $p_1' < \ldots < p_k'$ - индексы взятых вершин в ответе, посчитанном Куном, $p_i'$ - индексы взятых вершин в оптимальном ответе. Тогда $\exists i : p_i' < p_i$, но тогда $r(A_i)$ Кун посчитал неправильно. \\

Теперь добавим вершины и для правой доли. $a : L \rightarrow \mathbb{R}_+, b : R \rightarrow \mathbb{R}_+, w(uv) = a(u) + b(v)$. \\
Пусть $M_1$ - парсоч, построенный предыдущим алгоритмом для левой доли, $M_2$ - для правой доли. Рассмотрим $M_1 \cup M_2$ (в оригинале симметрическую разность, но в объединении просто будут циклы длины $2$). Тогда граф разбился на четные циклы и четные пути (иначе можно было увеличить парсоч). В циклах берем чередующиеся ребра (в том числе и циклах длины $2$), в путях мы должны выбрать один из 2 концов, выбираем больший. Несложно понять, что полученный парсоч будем весом $w(M_1) + w(M_2)$. \\

\verb'Теорема Кёнига' Размер максимального паросочетания в двудольном графе равен минимального вершинного покрытию. \\
\ti{Любое вершинное покрытие всегда не меньше любого паросочетания} - на каждом ребре из парсоча должна быть хотя бы $1$ вершина из вершинного покрытия. \\
Теперь предъявим какой-то парсоч равный какому-то вершинному покрытию. Ориентируем ребра парсоча справа-налево, а остальные - слева-направо. Запустим дфс из левой доли из вершин непокрытых паросочетанием ($L \backslash L(M)$, где $L(M)$ - множество покрытых вершин левой доли.) Тогда $L^{+}$ - множество вершин левой доли, до которых мы дошли, $L^{-}$ - вершины левой доли. до которых не дошли, $R^{+}$ - вершины правой доли, до которых дошли, $R^{-}$ - вершины правой доли, до которых не дошли. Тогда между $L^{+}$ и $R^{-}$ нету ребер, так как там не может быть ребер не из парсоча (иначе можем дойти до $R^{-}$ - ребра не из парсоча слева-направо), также не может быть ребер из парсоча, так как тогда конец этого ребра лежит в $L^{+}$ и покрыт, а значит мы туда попали, пройдя по этому ребру (так как у нас в каждую вершину левой доли может вести только ребро парсоча). (КЕК, УДАЧИ РЕБЯТА) \\
Тогда $L^- \cup R^+$ - вершинное покрытие. Все вершины $L^-$ покрыты, так как все непокрытые сразу же в $L^+$, все вершины $R^+$ покрыты, так как иначе есть удлиняющая цепь, а парсоч макссимальный. Между $L^-$ и $R^+$ не может быть ребер парсоча (справа налево), иначе можем дойти до $L^-$. Значит ребер парсоча  хотя бы столько же, сколько и вершин в вершинномм покрытии, то есть мы нашли парсоч, мощность которого равна мощности вершинного покрытия. Отюда получаем, чот $L^- \cup R^+$ - мин вершинное покрытие. \\
Отсюда $L^+ \cup R^-$ - максимальное независимое множество (как дополнение к мин вершинному покрытию). \\  

\verb'Задача 1'
Есть ДАГ (ориентированный ациклический граф). Надо покрыть все его вершины минимальным количеством вершинно-непересекающимися путями. \\ 
Рассмотрим выбранные ребра $M$, тогда путей будет $n - \abs{M}$. Значит нам надо выбрать максимальное количество ребер так, чтобы исходящая степень каждой вершины была не больше $1$, и входящая степень была не больше $1$. Тогда построим двудольный граф: в левой и правой доли - по $n$ вершин, тогда если в изначальном графе было ребро из $i$ в $j$, то проведем ребро из $i$ левой доли в $j$ правой доли (неориентированное). Тогда парсоч и есть множество ребер $M$. \\

\verb'Задача 2'
Теперь пути могут пересекаться. Рассмотрим транзитивное замыкание графа и решим предыдущую задачу. Тогда можно восстановить ответ из полученного (не успею немного дописать - там легко). \\

\verb'Теорема Дилворта' Размер максимальной антицепи равен количеству цепей в минимальном разбиении на цепи. (Понятно, что граф транзитивно замкнут по определению частично упорядоченного множества) \\
Мы уже умеем разбивать ЧУМ (частично упорядоченное множество) на минимальное количество цепей (\ti{Задача 1}). Научимся строить отсюда максимальную антицепь. Рассмотрим паросочетание $M$ из \ti{Задачи 1}. Тогда $\abs{VC} = \abs{M}$, $\abs{IS} = 2n - d$ в двудольном графе. Возьмем вершины, обе копии которых (из левой и правой доли) попали в $IS = L^+ \cup R^-$. Тогда получим антицепь (так как вершины лежат в $IS$). Теперь докажем, что полученная антицепь максимальна. Для этого докажем, что наши выбранные вершины (обе копии которых в $IS$) НЕ лежат в мин $VC$. Предположим обратное, тогда пусть обе копии какой-то вершины $v$ попали в min $VC$. По построению мин $VC$ обе копии $v$ покрыты парсочем, а концы соответствующих ребер парсоча ($a$ и $b$) не лежат в $min VC$. Но тогда $a \rightarrow v$, $v \rightarrow b$, но так как граф транзитивно замкнут, то $a \rightarrow b$, а значит это ребро не покрыто $min VC$, противоречие. \\ 


\end{document}