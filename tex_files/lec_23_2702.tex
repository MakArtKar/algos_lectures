\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[margin=1.5in,left=1cm,right=1cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{graphicx}
\usepackage{color}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{fancyhdr}



\title{Title}
\author{Амеличев Константин, ПМИ 191.}
\date{Date}

\newcommand{\problem}[2]{

\section {Задача #1}
\textbf {Постановка задачи.} {#2}

\textbf {Решение.}
}

\newcommand{\limit}[2]{\displaystyle \lim_{#1 \to #2}}

\newcommand{\rangesum}[2]{\displaystyle \sum_{#1}^{#2}}

\newcommand{\rangeint}[2]{\displaystyle \int_{#1}^{#2}}


\newcommand{\mintedparams}{
% frame=lines
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray    
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Амеличев Константин, ПМИ 191, @kik0s, \href{http://github.com/kik0s}{\textcolor{blue}{github}}, \href{http://codeforces.com/profile/kikos}{\textcolor{blue}{codeforces}}, \href{http://vk.com/i_tried_to_name_myself_kikos}{\textcolor{blue}{vk}}}
\fancyhead[RE,LO]{Лекция АиСД 27.02}

\begin{document}

\paragraph{Остовные деревья.} Пусть нам дан взвешенный граф. Мы хотим оставить в нем подмножество ребер минимального суммарного веса так, чтобы граф оставался связным.

\textbf{Лемма о безопасном ребре:} Для подмножества вершин $A$ есть ребро наименьшего веса, ведущее в дополнение к $A$. А именно, ведет из $u \in A$ в $v \notin A$. Существует остов, содержащий это ребро. Доказательство: От противного. Пусть мы не взяли ребро $u \leftrightarrow v$. Посмотрим на путь из $u$ в $v$ в дереве. В какой-то момент там нашлось ребро из $A$ в $V \setminus A$. Тогда можно удалить это ребро и заменить его на $v \leftrightarrow u$ --- стоимость не увеличится.

\paragraph{Алгоритм Прима.} По аналогии с алгоритмом Дейкстры будем поэтапно строить множество $A$ и добавлять в него минимальное ребро из леммы. Но тут важно, что лемма не гарантирует нам, что итоговый ответ хороший, потому что она говорила нам только о том, что ребро принадлежит какому-то ответу. Но есть усиленная версия леммы --- если ребро меньше по весу, чем все остальные, то тогда оно обязательно будет в минимальном остове. Поэтому надо как-то неявно задать веса ребер, чтобы они были различны (это в реальной жизни не нужно, только для доказательства), после чего алгоритм Прима нам уже будет гарантировать минимальный ответ.

\paragraph{Система непересекающихся множеств.} Структура данных, которая поддерживает следующие операции:

\begin{itemize}
\item $get(v)$ --- узнать, в каком множестве находится элемент $v$
\item $union(v, u)$ --- объединить множество, содержащее $v$ с множеством, содержащим $u$.
\item $check(v, u)$ --- проверить, находятся ли элементы в одном и том же множестве. Выражается через два $get$-а.
\end{itemize}


\paragraph{Алгоритм Краскала.} В начале упорядочим ребра по весу. Будем поддерживать какое-то множество компонент связности. Если для очередного ребра компоненты вершин различны, то можно сделать $union$ в $dsu$. Работает за $O(sort(m) + union(n) \cdot n + check(n) \cdot m)$

\paragraph{Алгоритм Борувки.} Выделим для каждой вершины минимальное ребро. Теперь добавим все эти ребра в остов, и сожмем граф. Дальше сделаем аналогичную операцию. Повторяем, пока не сойдется до одной компоненты. Каждый раз вершины соединяются в компоненты хотя бы по две вершины. Это значит, что итоговая оценка сложности будет $O(m \log n)$. Заметим, что на плотных графах Борувка работает за $O(m)$ --- каждый раз число ребер уменьшается в два раза.

Чтобы объединить две асимптотики, получим:

$$\frac{n^2}{4^k} \le m$$

$$4^k \ge \frac{n^2}{m}$$

$$k \approx \frac{1}{2} \log \frac{n^2}{m}$$

Значит, через $k$ операций мы получим граф, который можем считать полным (а на нем мы работаем за линию!). Тогда асимптотика это $O(m \log \frac{n^2}{m})$.

\end{document}
