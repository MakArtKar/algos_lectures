\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[margin=1.5in,left=1cm,right=1cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{graphicx}
\usepackage{color}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{fancyhdr}



\title{Title}
\author{Амеличев Константин, ПМИ 191.}
\date{Date}

\newcommand{\problem}[2]{

\section {Задача #1}
\textbf {Постановка задачи.} {#2}

\textbf {Решение.}
}

\newcommand{\limit}[2]{\displaystyle \lim_{#1 \to #2}}

\newcommand{\rangesum}[2]{\displaystyle \sum_{#1}^{#2}}

\newcommand{\mintedparams}{
% frame=lines
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray    
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Амеличев Константин, ПМИ 191, @kik0s, \href{http://github.com/kik0s}{\textcolor{blue}{github}}, \href{http://codeforces.com/profile/kikos}{\textcolor{blue}{codeforces}}, \href{http://vk.com/i_tried_to_name_myself_kikos}{\textcolor{blue}{vk}}}
\fancyhead[RE,LO]{Лекция АИСД 06.02}

\begin{document}

\paragraph{Оптимизационные задачи.} Часто человечество занимается тем, что берет перебор, и пытается сделать этот перебор оптимально возможным, чтобы работало ну очень-очень быстро. Для примера подобной задачи часто решают задачу коммивояжера (TSP), которая не имеет решения лучше, чем за экспоненту, но при этом современными методами решается для $n \sim 200$. Задача, между тем, актуальная, потому что транспортные компании, вот это все. Что должен сделать хороший перебор:
\begin{itemize}
    \item Запоминать промежуточные решения, чтобы у нас была возможность экстренно остановить перебор.
    \item Поставить отсечения таким образом, чтобы не идти в те состояния, где \textbf{точно} не будет решений.
\end{itemize}

\paragraph{Задача о ферзях.} Пусть мы хотим расставить $n$ ферзей на доске $n \times n$. Как закодировать состояние? Можно, например, с помощью $2n$ координат. Заметим, что гораздо лучше зафиксировать перестановку, а потом делать ферзей $(i, p_i)$. Тогда такие ферзи гарантированно не бьют друг друга по вертикали или горизонтали. Остается только проверить диагонали. Тогда если перебор будет строить перестановку слева направо, то мы сможем <<отрезать>> некоторые состояния (например, не ставить ферзя в те клетки, которые еще не бились предыдущими ферзями).

\paragraph{Branch \& bound method.}  Мы будем оптимизировать две вещи:

\paragraph{Границы.} Нам хочется понимать, когда мы сможем отрезать ветку перебора, чтобы не упустить оптимальный ответ. Например, выходить из ветки, если текущий ответ превышает нынешний оптимальный. Идеально --- ввести соответствующую функцию $f(p)$, и делать так:
\begin{minted}{c++}
    if (cur + f(p) > best) {
        return;
    }
\end{minted}

Такая функция должна, в случае задачи TSP, возвращать такую длину пути, который нам \textbf{точно} понадобится пройти. Например, можно взять вес остовного дерева на оставшихся вершинах. Тогда $span \le TSP \le 2 \cdot span$. Хорошая функция оценки!

Кроме того, очень хорошо иметь нормальное приближение ответа $best$. То есть, изначально как-нибудь (отжигом, жадником, итд) найти неплохой ответ, чтобы перебор не шел в заранее ущербные шаги.

\paragraph{Ветви.} Тут мы хотим сделать какую-то магию, чтобы перебирать ветки в правильном порядке. То есть, мы хотим запускать самые хорошие ветви в самом начале, особенно на первых слоях. Например, можно ввести оценочную функцию, и запускать перебор в порядке сортировки по этой оценочной функции. В задаче TSP, из физических соображений, можно запускать перебор сначала из ближайшей вершины к текущей. Также можно попытаться прыгнуть сразу на много уровней вниз, соптимизировав это какой-то простой динамикой ($dp_{mask, i, j}$ --- наименьшая длина пути через всю маску, если мы начали в $i$ и закончили в $j$) на маленьких подмножествах-кластерах. Тогда мы знали самый хороший способ взять какое-то подмножество, а тогда мы вместо $2^k$ ходов сделаем $k$ ходов. 

В ветвях есть много пространства для спекулятивных переборов. Например, можно идти в топ-$k$ веток по оценочной функции.

Можно инициализировать решение для неспекулятивного перебора решением из спекулятивного перебора!

\end{document}
