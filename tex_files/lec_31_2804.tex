\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[margin=1.5in,left=1cm,right=1cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}
\usepackage{graphicx}
\usepackage{color}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{fancyhdr}



\title{Title}
\author{Амеличев Константин, ПМИ 191.}
\date{Date}

\newcommand{\problem}[2]{

\section*{Задача #1}
\textbf {Постановка задачи.} {#2}

\textbf {Решение.}
}

\newcommand{\limit}[2]{\displaystyle \lim_{#1 \to #2}}

\newcommand{\rangesum}[2]{\displaystyle \sum_{#1}^{#2}}

\newcommand{\rangeint}[2]{\displaystyle \int_{#1}^{#2}}


\newcommand{\mintedparams}{
% frame=lines
% framesep=2mm,
% baselinestretch=1.2,
% bgcolor=LightGray    
}

\pagestyle{fancy}
\fancyhf{}
\fancyhead[LE,RO]{Амеличев Константин, ПМИ 191, @kik0s, \href{http://github.com/kik0s}{\textcolor{blue}{github}}, \href{http://codeforces.com/profile/kikos}{\textcolor{blue}{codeforces}}, \href{http://vk.com/i_tried_to_name_myself_kikos}{\textcolor{blue}{vk}}}
\fancyhead[RE,LO]{Лекция АиСД 28.04}

\begin{document}

\paragraph{$\pi$-функция.} Префикс-функция от строки $s$ определяется так: для каждой позиции $i$ это такая максимальная длина $l$, что $s_{0, l - 1} = s_{i - l + 1, i}$. То есть, мы берем наибольший префикс строки $s$, совпадающий с суффиксом, заканчивающимся в позиции $i$. При этом мы искусственно запрещаем делать $l = i + 1$ (то есть запрещаем брать префикс, совпадающий с суффиксом).

Как эффективно вычислять эту функцию? Можно заметить, что $\pi_{i + 1} \le \pi_i + 1$. При этом нижней границы нет. То есть, если мы будем итеративно считать префикс-функцию, то значения у нас не могут увеличиваться больше чем на 1 на каждом шаге, поэтому суммарно уменьшаться на 1 они будут $O(n)$ раз. 

Тогда префикс-функцию можно считать, например, так: сначала положить $\pi_i = \pi_{i - 1} + 1$, а потом постепенно уменьшать, и делать проверку на равенство подстрок с помощью хэшей. Но стандартный алгоритм делает так: он по очереди пытается приписать символ к $\pi_{i - 1},\ \pi_{\pi_{i - 1} - 1},\ \ldots$. Это верно, потому что если строка максимальна, то ее надо было продлить относительно прошлой подстроки. Если так не получалось сделать (символы не совпадали), то надо было попробовать максимальную длину, которая подходит, после $\pi_{i - 1}$. Но это ровно и есть значение префикс-функции от $s_{\pi_{i - 1}}$, потому что $s_{0, l - 1} = s_{i - l + 1, i}$, и потому что мы запретили брать префикс, равный суффиксу. Тогда этот алгоритм так же работает за $O(|s|)$.

Чтобы найти подстроку $t$ в строке $s$, можно запустить этот алгоритм на строке $t\$s$, после чего найти все точки, в которых $\pi_i = |t|$. Тут можно еще сэкономить память, и использовать только $O(|t|)$ памяти.

\paragraph{Автомат префикс-функции.} Мы хотим, чтобы Кнут-Морис-Пратт (поиск подстроки в строке) работал неамортизированно. Для этого можно сначала насчитать все переходы, и потом делать переходы. А именно, мы хотим делать $go_{v, c}$ --- переход из вершины $v$ по символу $c$. Вершину $v$ мы будем отождествлять с префиксом длины $v$. Тогда, если $s_{v + 1} = c$, то $go_{v, c} = v + 1$, а иначе $go_{v, c} = go_{\pi_{v}, c}$.

\paragraph{Z-функция.} В этот раз мы хотим найти для каждой позиции наибольший префикс $s_{0, n}$ и $s_{i, n}$. Тут функция монотонна, и ее можно считать наивно: пока можно увеличить значение, и оно корректно, надо увеличивать. Линейный алгоритм будет основан примерно на этом.

Будем строить z-функцию итеративно. Тогда каждый шаг алгоритма давал нам новую подстроку $s_{i, i + z_i}$. Мы их будем обозначать за $l_i,\ r_i$. Поддерживать мы из них будем всегда тот подотрезок, у которого правая граница как можно больше.

Тогда посмотрим на какое-то текущее $i$. Если $i \in [l, r]$, то $z_i \ge \min(r - i, z[i - l])$. Левое число нужно, чтобы мы не вышли за границу отрезка (потому что символы вне отрезка для нас неизвестные), а правое --- это то, как мы используем текущий отрезок $[l, r]$. А именно, поскольку мы знаем, что наша строка сейчас такая же, как и $s_{0, r - l}$, то можно <<подглядеть>>, чему было равно значение $z_{i'}$, где $i'$ соответствует парному символу для $i$.

Дальше мы можем просто наивно увеличивать значение $z$-функции, и этого хватит для линейного времени. Время окажется линейным, потому что наивное увеличение надо использовать, только если $i + z_i = r$ (то есть, если мы хотим выйти за границы текущего отрезка). А это значит, что у нас сдвинется число $r$. Поскольку $r$ может сдвинуться не более, чем $n$ раз, то получаем оценку $O(|s|)$ времени и памяти.

\end{document}
